diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index 9f9af8e5ad41d65ecc8d713c0cc65ef429e6bc40..6fd24ddc04fef314ec5625942fe6921c25c1702b 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -118,6 +119,10 @@
 #include "third_party/blink/renderer/platform/wtf/text/string_utf8_adaptor.h"
 #include "third_party/blink/renderer/platform/wtf/threading_primitives.h"
 
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+#include "brave/third_party/blink/brave_page_graph/page_graph.h"
+// #endif
+
 namespace blink {
 
 bool WebGLRenderingContextBase::webgl_context_limits_initialized_ = false;
@@ -2930,6 +2930,7 @@ WebGLActiveInfo* WebGLRenderingContextBase::getActiveAttrib(
     GLuint index) {
   if (!ValidateWebGLProgramOrShader("getActiveAttrib", program))
     return nullptr;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLPTR
   GLuint program_id = ObjectNonZero(program);
   GLint max_name_length = -1;
   ContextGL()->GetProgramiv(program_id, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH,
@@ -2961,6 +2962,7 @@ WebGLActiveInfo* WebGLRenderingContextBase::getActiveUniform(
     GLuint index) {
   if (!ValidateWebGLProgramOrShader("getActiveUniform", program))
     return nullptr;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLPTR
   GLuint program_id = ObjectNonZero(program);
   GLint max_name_length = -1;
   ContextGL()->GetProgramiv(program_id, GL_ACTIVE_UNIFORM_MAX_LENGTH,
@@ -2991,6 +2993,7 @@ absl::optional<HeapVector<Member<WebGLShader>>>
 WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program) {
   if (!ValidateWebGLProgramOrShader("getAttachedShaders", program))
     return absl::nullopt;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLOPT
 
   HeapVector<Member<WebGLShader>> shader_objects;
   for (GLenum shaderType : {GL_VERTEX_SHADER, GL_FRAGMENT_SHADER}) {
@@ -3005,6 +3008,7 @@ GLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program,
                                                    const String& name) {
   if (!ValidateWebGLProgramOrShader("getAttribLocation", program))
     return -1;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_MINUS_ONE
   if (!ValidateLocationLength("getAttribLocation", name))
     return -1;
   if (!ValidateString("getAttribLocation", name))
@@ -3038,6 +3042,7 @@ ScriptValue WebGLRenderingContextBase::getBufferParameter(
     GLenum pname) {
   if (isContextLost() || !ValidateBufferTarget("getBufferParameter", target))
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
 
   switch (pname) {
     case GL_BUFFER_USAGE: {
@@ -2971,6 +2976,7 @@ WebGLContextAttributes* WebGLRenderingContextBase::getContextAttributes()
     const {
   if (isContextLost())
     return nullptr;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLPTR
 
   WebGLContextAttributes* result =
       ToWebGLContextAttributes(CreationAttributes());
@@ -3068,7 +3085,25 @@ ScriptValue WebGLRenderingContextBase::getExtension(ScriptState* script_state,
       ToV8(extension, script_state->GetContext()->Global(),
            script_state->GetIsolate());
 
-  return ScriptValue(script_state->GetIsolate(), wrapped_extension);
+  ScriptValue result(script_state->GetIsolate(), wrapped_extension);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+  {
+    brave_page_graph::PageGraph* page_graph =
+      brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+    if (page_graph != nullptr) {
+      std::vector<const String> args;
+      args.push_back(name);
+      page_graph->RegisterWebAPICall("WebGLRenderingContext.getExtension",
+        args);
+
+      String page_graph_result;
+      result.ToString(page_graph_result);
+      page_graph->RegisterWebAPIResult("WebGLRenderingContext.getExtension",
+        page_graph_result);
+    }
+  }
+// #endif
+  return result;
 }
 
 ScriptValue WebGLRenderingContextBase::getFramebufferAttachmentParameter(
@@ -3174,6 +3179,7 @@ ScriptValue WebGLRenderingContextBase::getFramebufferAttachmentParameter(
                                          target, attachment))
     return ScriptValue::CreateNull(script_state->GetIsolate());
 
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (!framebuffer_binding_ || !framebuffer_binding_->Object()) {
     SynthesizeGLError(GL_INVALID_OPERATION, "getFramebufferAttachmentParameter",
                       "no framebuffer bound");
@@ -3167,13 +3205,74 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_ACTIVE_TEXTURE:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_ALIASED_LINE_WIDTH_RANGE:
-      return GetWebGLFloatArrayParameter(script_state, pname);
+      {
+        ScriptValue result = GetWebGLFloatArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALIASED_LINE_WIDTH_RANGE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ALIASED_POINT_SIZE_RANGE:
-      return GetWebGLFloatArrayParameter(script_state, pname);
+      {
+        ScriptValue result = GetWebGLFloatArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALIASED_POINT_SIZE_RANGE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ALPHA_BITS:
-      if (drawing_buffer_->RequiresAlphaChannelToBePreserved())
-        return WebGLAny(script_state, 0);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          drawing_buffer_->RequiresAlphaChannelToBePreserved()
+            ? WebGLAny(script_state, 0)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.ALPHA_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_ARRAY_BUFFER_BINDING:
       return WebGLAny(script_state, bound_array_buffer_.Get());
     case GL_BLEND:
@@ -3193,7 +3292,27 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_BLEND_SRC_RGB:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_BLUE_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.BLUE_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_COLOR_CLEAR_VALUE:
       return GetWebGLFloatArrayParameter(script_state, pname);
     case GL_COLOR_WRITEMASK:
@@ -3209,9 +3328,30 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_CURRENT_PROGRAM:
       return WebGLAny(script_state, current_program_.Get());
     case GL_DEPTH_BITS:
-      if (!framebuffer_binding_ && !CreationAttributes().depth)
-        return WebGLAny(script_state, kIntZero);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          !framebuffer_binding_ && !CreationAttributes().depth
+            ? WebGLAny(script_state, kIntZero)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.DEPTH_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_DEPTH_CLEAR_VALUE:
       return GetFloatParameter(script_state, pname);
     case GL_DEPTH_FUNC:
@@ -3234,7 +3374,27 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_GENERATE_MIPMAP_HINT:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_GREEN_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.GREEN_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+        return result;
+      }
+// #endif
     case GL_IMPLEMENTATION_COLOR_READ_FORMAT:
       return GetIntParameter(script_state, pname);
     case GL_IMPLEMENTATION_COLOR_READ_TYPE:
@@ -3242,26 +3402,247 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_LINE_WIDTH:
       return GetFloatParameter(script_state, pname);
     case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_CUBE_MAP_TEXTURE_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_FRAGMENT_UNIFORM_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_FRAGMENT_UNIFORM_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_RENDERBUFFER_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_RENDERBUFFER_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_TEXTURE_SIZE:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_TEXTURE_SIZE");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VARYING_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VARYING_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_ATTRIBS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_ATTRIBS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VERTEX_UNIFORM_VECTORS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VERTEX_UNIFORM_VECTORS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_MAX_VIEWPORT_DIMS:
+      {
+        ScriptValue result = GetWebGLIntArrayParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.MAX_VIEWPORT_DIMS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
       return GetWebGLIntArrayParameter(script_state, pname);
     case GL_NUM_SHADER_BINARY_FORMATS:
       // FIXME: should we always return 0 for this?
@@ -3275,11 +3656,51 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_POLYGON_OFFSET_UNITS:
       return GetFloatParameter(script_state, pname);
     case GL_RED_BITS:
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result = GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.RED_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_RENDERBUFFER_BINDING:
       return WebGLAny(script_state, renderbuffer_binding_.Get());
     case GL_RENDERER:
-      return WebGLAny(script_state, String("WebKit WebGL"));
+      {
+        ScriptValue result = WebGLAny(script_state, String("WebKit WebGL"));
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.RENDERER");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_SAMPLE_ALPHA_TO_COVERAGE:
       return GetBooleanParameter(script_state, pname);
     case GL_SAMPLE_BUFFERS:
@@ -3297,11 +3718,31 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
             pname, IdentifiabilityBenignStringToken(String(
                        ContextGL()->GetString(GL_SHADING_LANGUAGE_VERSION))));
       }
-      return WebGLAny(
+      {
+        ScriptValue result = WebGLAny(
           script_state,
           "WebGL GLSL ES 1.0 (" +
               String(ContextGL()->GetString(GL_SHADING_LANGUAGE_VERSION)) +
               ")");
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.SHADING_LANGUAGE_VERSION");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_STENCIL_BACK_FAIL:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_STENCIL_BACK_FUNC:
@@ -3317,9 +3758,30 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GL_STENCIL_BACK_WRITEMASK:
       return GetUnsignedIntParameter(script_state, pname);
     case GL_STENCIL_BITS:
-      if (!framebuffer_binding_ && !CreationAttributes().stencil)
-        return WebGLAny(script_state, kIntZero);
-      return GetIntParameter(script_state, pname);
+      {
+        ScriptValue result =
+          !framebuffer_binding_ && !CreationAttributes().stencil
+            ? WebGLAny(script_state, kIntZero)
+            : GetIntParameter(script_state, pname);
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.STENCIL_BITS");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_STENCIL_CLEAR_VALUE:
       return GetIntParameter(script_state, pname);
     case GL_STENCIL_FAIL:
@@ -3357,17 +3819,57 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
     case GC3D_UNPACK_COLORSPACE_CONVERSION_WEBGL:
       return WebGLAny(script_state, unpack_colorspace_conversion_);
     case GL_VENDOR:
-      return WebGLAny(script_state, String("WebKit"));
+      {
+        ScriptValue result = WebGLAny(script_state, String("WebKit"));
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.VENDOR");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VERSION:
       if (IdentifiabilityStudySettings::Get()->ShouldSample(
               blink::IdentifiableSurface::Type::kWebGLParameter)) {
         RecordIdentifiableGLParameterDigest(
             pname, IdentifiabilityBenignStringToken(
                        String(ContextGL()->GetString(GL_VERSION))));
       }
-      return WebGLAny(
+      {
+        ScriptValue result = WebGLAny(
           script_state,
           "WebGL 1.0 (" + String(ContextGL()->GetString(GL_VERSION)) + ")");
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("gl.VERSION");
+            page_graph->RegisterWebAPICall("WebGLRenderingContext.getParameter",
+              args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VIEWPORT:
       return GetWebGLIntArrayParameter(script_state, pname);
     case GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES:  // OES_standard_derivatives
@@ -3575,35 +3581,81 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
           "invalid parameter name, OES_standard_derivatives not enabled");
       return ScriptValue::CreateNull(script_state->GetIsolate());
     case WebGLDebugRendererInfo::kUnmaskedRendererWebgl:
-      if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
-        if (IdentifiabilityStudySettings::Get()->ShouldSample(
-                blink::IdentifiableSurface::Type::kWebGLParameter)) {
-          RecordIdentifiableGLParameterDigest(
-              pname, IdentifiabilityBenignStringToken(
-                         String(ContextGL()->GetString(GL_RENDERER))));
-        }
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_RENDERER)));
-      }
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, WEBGL_debug_renderer_info not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
+      BRAVE_WEBGL_GET_PARAMETER_UNMASKED_RENDERER
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
+          if (IdentifiabilityStudySettings::Get()->ShouldSample(
+                  blink::IdentifiableSurface::Type::kWebGLParameter)) {
+            RecordIdentifiableGLParameterDigest(
+                pname, IdentifiabilityBenignStringToken(
+                           String(ContextGL()->GetString(GL_RENDERER))));
+          }
+          result = WebGLAny(script_state,
+                            String(ContextGL()->GetString(GL_RENDERER)));
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, WEBGL_debug_renderer_info not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.UNMASKED_RENDERER_WEBGL");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case WebGLDebugRendererInfo::kUnmaskedVendorWebgl:
-      if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
-        if (IdentifiabilityStudySettings::Get()->ShouldSample(
-                blink::IdentifiableSurface::Type::kWebGLParameter)) {
-          RecordIdentifiableGLParameterDigest(
-              pname, IdentifiabilityBenignStringToken(
-                         String(ContextGL()->GetString(GL_VENDOR))));
-        }
-        return WebGLAny(script_state,
-                        String(ContextGL()->GetString(GL_VENDOR)));
-      }
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, WEBGL_debug_renderer_info not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
+      BRAVE_WEBGL_GET_PARAMETER_UNMASKED_VENDOR
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kWebGLDebugRendererInfoName)) {
+          if (IdentifiabilityStudySettings::Get()->ShouldSample(
+                  blink::IdentifiableSurface::Type::kWebGLParameter)) {
+            RecordIdentifiableGLParameterDigest(
+                pname, IdentifiabilityBenignStringToken(
+                           String(ContextGL()->GetString(GL_VENDOR))));
+          }
+          result = WebGLAny(script_state,
+                            String(ContextGL()->GetString(GL_VENDOR)));
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, WEBGL_debug_renderer_info not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.UNMASKED_VENDOR_WEBGL");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
+      }
     case GL_VERTEX_ARRAY_BINDING_OES:  // OES_vertex_array_object
       if (ExtensionEnabled(kOESVertexArrayObjectName) || IsWebGL2()) {
         if (!bound_vertex_array_object_->IsDefaultObject())
@@ -3399,14 +3949,37 @@ ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
           "invalid parameter name, OES_vertex_array_object not enabled");
       return ScriptValue::CreateNull(script_state->GetIsolate());
     case GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT:  // EXT_texture_filter_anisotropic
-      if (ExtensionEnabled(kEXTTextureFilterAnisotropicName)) {
-        return GetFloatParameter(script_state,
-                                 GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+      {
+        ScriptValue result;
+        if (ExtensionEnabled(kEXTTextureFilterAnisotropicName)) {
+          result = GetFloatParameter(script_state,
+                                     GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+        } else {
+          SynthesizeGLError(
+              GL_INVALID_ENUM, "getParameter",
+              "invalid parameter name, "
+              "EXT_texture_filter_anisotropic not enabled");
+          result = ScriptValue::CreateNull(script_state->GetIsolate());
+        }
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+        {
+          brave_page_graph::PageGraph* page_graph =
+            brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+          if (page_graph != nullptr) {
+            std::vector<const String> args;
+            args.push_back("ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT");
+            page_graph->RegisterWebAPICall(
+              "WebGLRenderingContext.getParameter", args);
+
+            String page_graph_result;
+            result.ToString(page_graph_result);
+            page_graph->RegisterWebAPIResult(
+              "WebGLRenderingContext.getParameter", page_graph_result);
+          }
+        }
+// #endif
+        return result;
       }
-      SynthesizeGLError(
-          GL_INVALID_ENUM, "getParameter",
-          "invalid parameter name, EXT_texture_filter_anisotropic not enabled");
-      return ScriptValue::CreateNull(script_state->GetIsolate());
     case GL_MAX_COLOR_ATTACHMENTS_EXT:  // EXT_draw_buffers BEGIN
       if (ExtensionEnabled(kWebGLDrawBuffersName) || IsWebGL2())
         return WebGLAny(script_state, MaxColorAttachments());
@@ -3682,6 +3690,7 @@ ScriptValue WebGLRenderingContextBase::getProgramParameter(
   // intended to prevent applications from entering an infinite polling loop.
   if (isContextLost() && pname == GL_COMPLETION_STATUS_KHR)
     return WebGLAny(script_state, true);
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (!ValidateWebGLProgramOrShader("getProgramParamter", program)) {
     return ScriptValue::CreateNull(script_state->GetIsolate());
   }
@@ -3737,6 +3746,7 @@ ScriptValue WebGLRenderingContextBase::getProgramParameter(
 String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program) {
   if (!ValidateWebGLProgramOrShader("getProgramInfoLog", program))
     return String();
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_STRING
   GLStringQuery query(ContextGL());
   return query.Run<GLStringQuery::ProgramInfoLog>(ObjectNonZero(program));
 }
@@ -3747,6 +3757,7 @@ ScriptValue WebGLRenderingContextBase::getRenderbufferParameter(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (target != GL_RENDERBUFFER) {
     SynthesizeGLError(GL_INVALID_ENUM, "getRenderbufferParameter",
                       "invalid target");
@@ -3798,6 +3809,7 @@ ScriptValue WebGLRenderingContextBase::getShaderParameter(
   // intended to prevent applications from entering an infinite polling loop.
   if (isContextLost() && pname == GL_COMPLETION_STATUS_KHR)
     return WebGLAny(script_state, true);
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (!ValidateWebGLProgramOrShader("getShaderParameter", shader)) {
     return ScriptValue::CreateNull(script_state->GetIsolate());
   }
@@ -3829,6 +3841,7 @@ ScriptValue WebGLRenderingContextBase::getShaderParameter(
 String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader) {
   if (!ValidateWebGLProgramOrShader("getShaderInfoLog", shader))
     return String();
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_STRING
   GLStringQuery query(ContextGL());
   return query.Run<GLStringQuery::ShaderInfoLog>(ObjectNonZero(shader));
 }
@@ -3859,6 +3872,7 @@ WebGLShaderPrecisionFormat* WebGLRenderingContextBase::getShaderPrecisionFormat(
   GLint precision = 0;
   ContextGL()->GetShaderPrecisionFormat(shader_type, precision_type, range,
                                         &precision);
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_GETSHADERINFOLOG
   auto* result = MakeGarbageCollected<WebGLShaderPrecisionFormat>(
       range[0], range[1], precision);
   if (IdentifiabilityStudySettings::Get()->ShouldSample(
@@ -3621,6 +3635,78 @@ WebGLShaderPrecisionFormat* WebGLRenderingContextBase::getShaderPrecisionFormat(
   if (!ValidateShaderType("getShaderPrecisionFormat", shader_type)) {
     return nullptr;
   }
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLPTR
+
+// #if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+  {
+    std::string precision_str;
+    switch (precision_type) {
+      case GL_LOW_FLOAT:
+        precision_str = "gl.LOW_FLOAT";
+        break;
+      case GL_MEDIUM_FLOAT:
+        precision_str = "gl.MEDIUM_FLOAT";
+        break;
+      case GL_HIGH_FLOAT:
+        precision_str = "gl.HIGH_FLOAT";
+        break;
+      case GL_LOW_INT:
+        precision_str = "gl.LOW_INT";
+        break;
+      case GL_MEDIUM_INT:
+        precision_str = "gl.MEDIUM_INT";
+        break;
+      case GL_HIGH_INT:
+        precision_str = "gl.HIGH_INT";
+        break;
+      default:
+        SynthesizeGLError(GL_INVALID_ENUM, "getShaderPrecisionFormat",
+                          "invalid precision type");
+        return nullptr;
+    }
+
+    std::string shader;
+    switch (shader_type) {
+      case GL_FRAGMENT_SHADER:
+        shader = "gl.FRAGMENT_SHADER";
+        break;
+      case GL_VERTEX_SHADER:
+        shader = "gl.VERTEX_SHADER";
+        break;
+      default:
+        break;
+    }
+
+    GLint range[2] = {0, 0};
+    GLint precision = 0;
+    ContextGL()->GetShaderPrecisionFormat(shader_type, precision_type, range,
+                                          &precision);
+    WebGLShaderPrecisionFormat* result =
+      MakeGarbageCollected<WebGLShaderPrecisionFormat>(range[0], range[1],
+                                                       precision);
+
+    brave_page_graph::PageGraph* page_graph =
+      brave_page_graph::PageGraph::GetFromExecutionContext(*Host()->GetTopExecutionContext());
+    if (page_graph != nullptr) {
+      std::vector<const String> args;
+      args.push_back(shader.c_str());
+      args.push_back(precision_str.c_str());
+      page_graph->RegisterWebAPICall(
+        "WebGLRenderingContext.getShaderPrecisionFormat", args);
+
+      std::stringstream buffer;
+      buffer << "rangeMin: " << result->rangeMin()
+        << ", rangeMax: " << result->rangeMax()
+        << ", precision: " << result->precision();
+
+      String res(buffer.str().c_str());
+      page_graph->RegisterWebAPIResult(
+        "WebGLRenderingContext.getShaderPrecisionFormat", res);
+    }
+
+    return result;
+  }
+// #endif
   switch (precision_type) {
     case GL_LOW_FLOAT:
     case GL_MEDIUM_FLOAT:
@@ -3871,6 +3885,7 @@ WebGLShaderPrecisionFormat* WebGLRenderingContextBase::getShaderPrecisionFormat(
 String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader) {
   if (!ValidateWebGLProgramOrShader("getShaderSource", shader))
     return String();
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_STRING
   return EnsureNotNull(shader->Source());
 }
 
@@ -3900,6 +3915,7 @@ ScriptValue WebGLRenderingContextBase::getTexParameter(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (!ValidateTextureBinding("getTexParameter", target))
     return ScriptValue::CreateNull(script_state->GetIsolate());
   switch (pname) {
@@ -3934,6 +3950,7 @@ ScriptValue WebGLRenderingContextBase::getUniform(
     const WebGLUniformLocation* uniform_location) {
   if (!ValidateWebGLProgramOrShader("getUniform", program))
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   DCHECK(uniform_location);
   if (uniform_location->Program() != program) {
     SynthesizeGLError(GL_INVALID_OPERATION, "getUniform",
@@ -4193,6 +4210,7 @@ WebGLUniformLocation* WebGLRenderingContextBase::getUniformLocation(
     const String& name) {
   if (!ValidateWebGLProgramOrShader("getUniformLocation", program))
     return nullptr;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_NULLPTR
   if (!ValidateLocationLength("getUniformLocation", name))
     return nullptr;
   if (!ValidateString("getUniformLocation", name))
@@ -4217,6 +4235,7 @@ ScriptValue WebGLRenderingContextBase::getVertexAttrib(
     GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_SCRIPT_VALUE
   if (index >= max_vertex_attribs_) {
     SynthesizeGLError(GL_INVALID_VALUE, "getVertexAttrib",
                       "index out of range");
@@ -4294,6 +4313,7 @@ int64_t WebGLRenderingContextBase::getVertexAttribOffset(GLuint index,
                                                          GLenum pname) {
   if (isContextLost())
     return 0;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_ZERO
   GLvoid* result = nullptr;
   // NOTE: If pname is ever a value that returns more than 1 element
   // this will corrupt memory.
@@ -4641,6 +4661,7 @@ void WebGLRenderingContextBase::ReadPixelsHelper(GLint x,
                                                  int64_t offset) {
   if (isContextLost())
     return;
+  BRAVE_WEBGL_RENDERING_CONTEXT_BASE_RETURN
   // Due to WebGL's same-origin restrictions, it is not possible to
   // taint the origin using the WebGL API.
   DCHECK(Host()->OriginClean());
